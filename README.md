#JS笔记

##Let&Const
###let关键字
* 绑定到所在区域,外部不可见
* 外部同名变量同内部变量互不影响
* 代码块内let声明之前使用某变量就会报错,它并不会像**var**那样存在提升的特性,也就是暂时性死区
* 同一作用域内不可重复声明同一个变量

###const关键字
* 常量的值声明后不能改变
* 声明必须赋值
* 其它同let



##Destructuring

按等号右侧的值来给等号左侧的变量赋值,前提是右侧的值必须
* 转换成对象后具备Iterator接口
* 本身自带Iterator接口
如果一个右侧的成员不===undefined, 默认值不会生效.
```
let [a, b, c] = [1, 2, 3]
a // 1
b // 2
c // 3

let [ , , z] = [1, 2, 3]
z // 3

let [yoo, ...xoo] = [1,2,3,4]
yoo // 1
xoo // [2,3,4]

let [woo] = [];
woo // undefined

//默认值
let [doo = 6] = [];
doo // 6
```

对象解构变量名与属性名一致的情况, 解构失败则为undefined.

```
let {a, b, c} = {b: 123, a: 456};
a // 456
b // 123
c // undefined
```

变量名与属性名不一致的情况
```
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
//实质上是
let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```

字符串的解构

```
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

##字符串
1. \uxxxx形式的Unicode表示法
	* \u0000 - \uFFFF

```
"\u0061" === "a"	//true
//超出\u0000 - \uFFFF这个范围字符
"\uD842\uDFB7" === "𠮷"	或
"\u{20BB7}" === "𠮷"

```

2. 可以使用for..of遍历

```
for( let i of "abc") {
    console.log(i);
}
// a
// b
// c
```

##Module
###export命令
**export命令用于规定模块的对外接口**,一个模块就是一个独立的文件, 除非使用export命令输出变量, 不然文件内的所有变量外部都不可访问.

```
export var firstName = "bob";
export var lastName = "mike";
export var year = 1000;
//等同于
var firstName = "bob";
var lastName = "mike";
var year = 1000;
export {firstName, lastName, year};
```
* 输出函数或类

```
export function someFn() {
	//xxxxx
}
//等同于
function someFn() {
	//xxxxx
};
export {someFn}
```
* 但要注意会出错的情况

```
export 1;

var  m = 1;
export m;
//没有提供对外的接口, 1只是1个值, 不是接口.
//输出函数或类也遵循相同语法
//正确写法是这样
export var m = 1;

var m = 1;
export {m};

var n = 1;
export {n as m};
```
* export可以出现在模块顶层的任意位置. 如果处于块级作用域内会报错.

```
//报错
function woo () {
	export var doo = 123;
} 
```

###import命令

* 使用导入模块的部分接口
```
//大括号中的变量名必须与被导入模块中导出的模块名称相同(类似对象的解构)
import {a} from "./what";
```

* 使用别名

```
import {a as b} from "./what";
//使用b的代码...
```
* 命令提升

```
//不会报错,import会提升至整个模块头部
foo();
import {foo} from "./some-mod";
```

* 不能使用表达式和变量

```
//报错
import {'f' + "oo"} from "./some"

let mod = "./some";
import { foo } from mod;
```
* 重复执行同一句import, 那么只会执行一次

```
import 'lodash';
import 'lodash';
//只会执行一次
```
* 整体加载

```
//使用别名
import * as woo from "./doo";
//不使用别名
import lodash from "lodash";
```






**!必输参数们为加粗**
##Array

###Array.from()
**描述 : 使类数组对象或可遍历对象转换为真正的数组**
**参数 : **
* **要转换的对象**
* 对象在返回前的处理函数
* 执行参数2时的 *this* 值

```
Array.from( 1, 2, 3 )		//[1,2,3]
```

###Array.isArray()
**描述 : 判断参数是否是一个数组**
**参数 :**
* **要判断的对象**
	* 传入多个参数时第一个参数以外的多余参数会被忽略
```
Array.isArray( [1,2,3] )		//true
```

###Array.of()
**描述 : 按参数的传入顺序返回一个新的数组**
**参数 :**
* 参数个数取值范围为 [0, ∞]
* 不传参数则返回空数组
* 同array构造器不同, 本方法传入一个参数则返回一个只有参数本身的数组

```
Array.of( 1,2,3 )		//[1, 2, 3]
```

###[ ].copyWithin()
**描述 : 拷贝数组的部分元素到同一数组的不同位置, 不改变数组的长度, 返回修改后的原数组(原数组会被改变)**
**参数 : **
* **从何处开始复制并重复原数组本身**
	* 如果是负数, 则从数组末尾开始算起.
	* 如果参数大于数组长度, 将不会执行操作.
	* 如果本参数在参数2之后, 复制的序列将被修改.
* 开始复制元素的起始索引
	* 如果是负数, 将从末尾开始算起
	* 如果被忽略, 将从0开始复制
* 开始复制元素的结束索引
	* 拷贝的位置不包括这个位置的元素
	* 如果是负数, 将从末尾开始计算
	* 如果被忽略, 将会复制到arr.length

```
好绕啊 fark!
```
###[ ].entries()
**描述 : 每次调用返回一个Iterator对象, 使用next()来访问**  

```
var a = [1, 2, 3, 4],
	b = a.entries();
	b.next().value      //[0,1]   //索引, 值对
	b.next().value      //[1,2]
	b.next().value      //[2,3]
	b.next().value      //[3,4]
```

###[ ].every()
**描述 : 测试数组的每个元素是否都通过了测试**
**参数 :** 
* **测试函数**
	* **指代数组中的每个元素**
	* 数组中的每个元素的索引
	* 数组本身
* 执行测试函数时this的值

```
[1, 2, 3, 4].every( x => x > 2 );		//false
```

###[ ].fill()
**描述 : 以指定元素填充数组的某个特定区间, 返回被修改后的原数组(原数组也会被改变)**
**参数 :** 
* **用来填充数组的元素**
* 开始索引, 默认0
	* 如果提供了负值, 将被换算为数组长度 + 负值.
* 结束索引, 默认为数组的长度
	* 操作会填充到结束索引的前一个位置
	* 负值计算同参数2 

```
[1, 2, 3, 4, 5, 6].fill(2)       //[2,2,2,2,2,2]
[1, 2, 3, 4, 5, 6].fill(2,1,3)   //[1,2,2,4,5,6]
```

###[ ].filter()
**描述 : 返回数组中所有通过了测试的元素(不会改变原数组)**
**参数 :** 
* **测试函数**
	* **指代数组中的每个元素**
	* 数组中的每个元素的索引
	* 数组本身
* 执行测试函数时this的值

```
[1, 2, 3, 4].filter( x => x > 2 );		//[3,4]
```

###[ ].find()
**描述 : 返回数组中所有通过了测试的元素中的第一个值(不会改变原数组)**
**参数 :** 
* **测试函数**
	* **指代数组中的每个元素**
	* 数组中的每个元素的索引
	* 数组本身
* 执行测试函数时this的值

```
[1, 2, 3, 4].find( x => x > 2 );		//3
```

###[ ].findIndex()
**描述 : 返回数组中所有通过了测试的元素中的第一个值的索引(不会改变原数组),找不到返回 -1**
**参数 :** 
* **测试函数**
	* **指代数组中的每个元素**
	* 数组中的每个元素的索引
	* 数组本身
* 执行测试函数时this的值

```
[1, 2, 3, 4].findIndex( x => x > 2 );		//2
```

###[ ].includes()
**描述 : 找到数组中的指定值则返回true, 反之则返回false**
**参数 :** 
* **要寻找的元素**
* 指定要开始寻找的索引

```
[1, 2, 3, 4].includes( 1 );    	  //true
[1, 2, 3, 4].includes( 1, 1 );    //false
```




###[ ].keys()
**描述 : 每次调用返回一个Iterator对象, 使用next()来访问**  

```
var a = [1, 2, 3, 4],
	b = a.keys();
	b.next().value      //[0,1]   //返回索引
	b.next().value      //[1,2]
	b.next().value      //[2,3]
	b.next().value      //[3,4]
```

###[ ].lastIndexOf()
**描述 : 找到数组中指定值在数组中最后一次出现的位置, 未找到则返回-1**
**参数 :** 
* **要寻找的元素**
* 从本位置开始逆向查找

```
[1, 2, 3, 4].lastIndexOf( 2 );    //1

```

###[ ].map()
**描述 : 对数组的每个元素执行对应方法(不会改变原数组)**
**参数 :** 
* **对应函数**
	* **指代数组中的每个元素**
	* 数组中的每个元素的索引
	* 数组本身
* 执行测试函数时this的值

```
[1, 2, 3, 4].map( x => x * 2 );		//[2,4,6,8]
```
###[ ].reduce()
**描述 : 接收一个函数作为累加器, 使数组中的元素从左到右开始合并, 最终成为一个值.**
**参数 :**
* **累加器函数, 类似sort**
	* **上一次调用返回的值, 或是提供的初始值**
	* **数组中正在处理的元素**
	* 数组中正在处理的元素索引
	* 数组本身
* 第一次调用累加器的的第一个参数

```
[0, 1, 2, 3, 4].reduce( (a, b) => {
  return a + b;
}, 0);			//10
```

|×  |  上次调用返回值  |  当前值  |  当前索引  |  数组  |  返回值  |
|:-:|:-------------:|:-------:|:---------:|:-----:|:-------:|
|1st调用   | 0 | 1 | 1 | [ 0, 1, 2, 3, 4 ] | 1  |
|2nd调用   | 1 | 2 | 2 | [ 0, 1, 2, 3, 4 ] | 3  |
|3rd调用   | 3 | 3 | 3 | [ 0, 1, 2, 3, 4 ] | 3  |
|4th调用   | 6 | 4 | 4 | [ 0, 1, 2, 3, 4 ] | 10 |

###[ ].reduceRight()
**描述 : 接收一个函数作为累加器, 使数组中的元素从右到左开始合并, 最终成为一个值.**
**参数 :**
* **累加器函数, 类似sort**
	* **上一次调用返回的值, 或是提供的初始值**
	* **数组中正在处理的元素**
	* 数组中正在处理的元素索引
	* 数组本身
* 第一次调用累加器的的第一个参数

```
['a', 'b', 'c', 'd'].reduceRight( (a, b) => {
  return a + b;
});			'dcba'

//同reduce的区别是执行顺序

['a', 'b', 'c', 'd'].reduce( (a, b) => {
  return a + b;
});			'abcd'

```

###[ ].some()
**描述 : 是否至少有一个元素通过了测试函数, 是则返回true, 否则返回false.**

```
[1, 2, 3, 4].some(( val ) => {
	  return val > 3;
}) 	//true
```


##Function

###rest参数

**语法**

```
function foo(...a) {
    //使用参数a
    //a默认为1个空数组
}
```
* 参数只有一个或者多参数但只有**最后一个**参数可以使用rest形式
* 函数调用时, rest参数**前面的所有参数**必须正常填充
* 没有传实参的rest只是一个**空数组**
* 完全替代arguments对象

###默认参数

**语法**

* 不用arguments对象too

```
function bar(a = 1,b = 2,c = 3) {
	//操作参数
}
```

```
function bar(a = 1,b = 2,c = 3) {
	return [a,b,c];
}

bar(0,0,0)								>_ [0,0,0]
bar(undefined,0,0)						>_ [1,0,0]
bar(undefined,undefined,undefined)		>_ [1,2,3]
```

```
function boo(a = 1, b) { ... }
//等价于
function boo(a = 1, b = undefined) { ... }
```

##String

###" ".startsWith()
**描述 : 判断当前字符串是否以参数1开头, 返回布尔值**
**参数 :** 
* **要搜索的子字符串**
* 在原始字符串中搜索子串的开始位置, 默认为0

```
"abc".startsWith("a")		    //true
"abc".startsWith("b", 1)		//true
```


###" ".endsWith()
**描述 : 判断当前字符串是否以参数1结尾, 返回布尔值**
**参数 :** 
* **要搜索的子字符串**
* 在原始字符串中搜索子串的结束位置, 相当于在父串执行slice(0, 本参数-1)后再进行查找, 默认为父串的length

```
"abc".endsWith("c")		    //true
"abc".endsWith("c", 3)		//true
```

###" ".includes()
**描述 : 判断当前字符串是否含有参数1, 返回布尔值, 区分大小写**
**参数 :** 
* **要搜索的子字符串**
* 在原始字符串中搜索子串的开始位置, 默认为0

```
"abc".includes("c")		    //true
"abc".includes("c", 2)		//true
```

###" ".repeat()
**描述 : 重复当前字符串若干次**
**参数 :** 
* **要重复的次数**
	* 0和NaN会返回空字符串
	* 小数会自动向下取整
	* 小于0会报错
	* 取值范围是[0, infinity)

```
"x".repeat(0)		    //""
"x".repeat(3.9)		    //"xxx"
```

###" ".trim()
**描述 : 去掉当前字符串2端的空白字符(space tab no-break space)以及所有的行结束符**

```
"x ".trim()		    	//"x"
" x ".trim()		    //"x"
```

###" ".trimLeft()
**描述 : 去掉当前字符串左侧的空白字符(space tab no-break space)以及所有的行结束符**

```
" x ".trimLeft()		    //"x "
```

###" ".trimRight()
**描述 : 去掉当前字符串右侧的空白字符(space tab no-break space)以及所有的行结束符**

```
" x ".trimRight()		    //" x"
```




